function data = calculateVoronoiWeights(data)
% CALCULATEVORONOIWEIGHTS Calculates Voronoi weights for points on a spherical shell
%
% Inputs:
%   data - Data structure containing points generated by getShellPoints
%          Must have fields:
%          .pos - Cartesian coordinates of points
%          .sphpos - Spherical coordinates of points
%          .grid_type - Type of grid ('uniform', 'random', or 'modulated')
%
% Outputs:
%   data - Updated data structure with added field:
%          .voronoi_weights - Vector of weights for numerical integration
%
% Note: This function uses the convex hull method to compute approximate Voronoi
%       cells on the sphere, then calculates the area of each spherical polygon as the weight.

% Get grid type
if ~isfield(data, 'grid_type')
    data.grid_type = 'uniform';
end
grid_type = lower(data.grid_type);

% Get cartesian coordinates of the points
points = data.pos;
num_points = size(points, 1);

% Get spherical coordinates for radius information
sph_coords = data.sphpos;

% Normalize to unit sphere for Voronoi calculation
norms = sqrt(sum(points.^2, 2));
unit_points = points ./ repmat(norms, 1, 3);

% Compute convex hull of the points
try
    hull = convhull(unit_points);
catch
    % If points are nearly coplanar, add small random perturbation
    if num_points > 3
        perturb = 1e-6 * randn(size(unit_points));
        unit_points = unit_points + perturb;
        % Re-normalize
        norms = sqrt(sum(unit_points.^2, 2));
        unit_points = unit_points ./ repmat(norms, 1, 3);
        hull = convhull(unit_points);
    else
        error('Cannot compute convex hull with less than 4 non-coplanar points');
    end
end

% Initialize weights
weights = zeros(num_points, 1);

% Get all triangular faces from the convex hull
triangles = hull;
num_triangles = size(triangles, 1);

% For each triangle in the hull
for i = 1:num_triangles
    % Get the vertices of the triangle
    v1 = unit_points(triangles(i, 1), :);
    v2 = unit_points(triangles(i, 2), :);
    v3 = unit_points(triangles(i, 3), :);
    
    % Calculate the area of the spherical triangle
    % Method: Calculate the spherical excess (sum of angles minus pi)
    
    % Compute the angles of the spherical triangle
    a = acos(dot(v2, v3));
    b = acos(dot(v1, v3));
    c = acos(dot(v1, v2));
    
    % Compute the angles using the spherical law of cosines
    A = acos((cos(a) - cos(b)*cos(c))/(sin(b)*sin(c)));
    B = acos((cos(b) - cos(a)*cos(c))/(sin(a)*sin(c)));
    C = acos((cos(c) - cos(a)*cos(b))/(sin(a)*sin(b)));
    
    % Spherical excess formula for area
    area = A + B + C - pi;
    
    % Distribute the area to the three vertices of the triangle
    weights(triangles(i, 1)) = weights(triangles(i, 1)) + area/3;
    weights(triangles(i, 2)) = weights(triangles(i, 2)) + area/3;
    weights(triangles(i, 3)) = weights(triangles(i, 3)) + area/3;
end
% Remove negligible imaginary components from weights
if ~isreal(weights)
    fprintf('Note: Small imaginary components (max: %.2e) found in %d weights. Taking real part.\n', ...
        max(abs(imag(weights))), sum(imag(weights) ~= 0));
    weights = real(weights);
end
% Normalize the weights to sum to 4*pi (total surface area of unit sphere)
weights = (4*pi) * weights / sum(weights);

% Scale weights by r^2 to account for the radius of the shell
% (surface area of a sphere is 4*pi*r^2)
if ~strcmp(grid_type, 'modulated')
    % For uniform or random grids, all points have the same radius
    r = data.cfg.headshape.radius;
    weights = weights * r^2;
else
    % For modulated grid, each point may have a different radius
    % Scale each weight by its respective radius squared
    r_squared = sph_coords(:,1).^2;
    weights = weights .* r_squared;
end

% Store the weights directly in the main data structure
data.weights = weights;

% If a grid structure exists, also store it there for consistency
if isfield(data, 'grid')
    data.grid.weights = weights;
end

% Store weights in specific grid structures if they exist (for 'all' grid_type)
if strcmp(grid_type, 'all')
    if isfield(data, 'uniform_grid')
        data.uniform_grid.weights = weights;
    end
    if isfield(data, 'random_grid')
        % Note: For completeness, we would need to recalculate weights for each grid
        % This is a simplified version that uses the same weights
        data.random_grid.weights = weights;
    end
    if isfield(data, 'modulated_grid')
        % Note: For completeness, we would need to recalculate weights for each grid
        % This is a simplified version that uses the same weights
        data.modulated_grid.weights = weights;
    end
end

% Calculate weight sum and error for verification
if ~strcmp(grid_type, 'modulated')
    % For uniform or random grids, expected total is 4*pi*r^2
    r = data.cfg.headshape.radius;
    expected_sum = 4*pi*r^2;
    actual_sum = sum(weights);
    relative_error = abs(actual_sum - expected_sum) / expected_sum;
    
    % Store error information
    data.weight_sum = actual_sum;
    data.weight_error = relative_error;
    
    % Also store in grid if it exists
    if isfield(data, 'grid')
        data.grid.weight_sum = actual_sum;
        data.grid.weight_error = relative_error;
    end
else
    % For modulated grid, expected sum depends on individual radii
    % Just store the sum of weights
    data.weight_sum = sum(weights);
    
    % Also store in grid if it exists
    if isfield(data, 'grid')
        data.grid.weight_sum = sum(weights);
    end
end

end